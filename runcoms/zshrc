#
# Executes commands at the start of an interactive session.
#
# Authors:
#   Sorin Ionescu <sorin.ionescu@gmail.com>
#

# zmodload zsh/zprof

# Source Prezto.
if [[ -s "${ZDOTDIR:-$HOME}/.zprezto/init.zsh" ]]; then
    source "${ZDOTDIR:-$HOME}/.zprezto/init.zsh"
fi

##### Aliases #####

## git
alias gws='git status'
alias gds='git diff --staged'
alias gp='git pull'
alias gpo='git pull origin'
alias grh='git reset HEAD'

## ipython
alias ipy='ipython'
alias ipy2='ipython2'
alias ipy3='ipython3'
alias jpn='jupyter notebook'

## pip
alias pip2i='pip install --upgrade'
alias pip3i='pip3 install --upgrade'
alias pip2l='pip list'
alias pip3l='pip3 list'
alias pip2o='pip list --outdated'
alias pip3o='pip3 list --outdated'

## pyenv
alias pyenvg='pyenv global'
alias pyenvi='pyenv install'
alias pyenvil='pyenv install --list'
alias pyenvl='pyenv local'
alias pyenvs='pyenv versions'
alias pyenvr='pyenv rehash'


#### Utilities ####

path=(
    $HOME/.local/bin      # my local overrides

    $HOME/.cargo/bin      # rust
    $GOPATH/bin           # go

    $path
)

# export PATH

if [[ "$OSTYPE" == darwin* ]]; then
    ## homebrew and cask
    alias brewf='brew info'
    alias caskf='brew cask info'

    ## emacs
    alias emacs='open -a /usr/local/opt/emacs-mac/Emacs.app'
    alias e='emacs'
    alias et='/usr/local/bin/emacs'
    alias ed='open -a /usr/local/opt/emacs-mac/Emacs.app --args --debug-init'
    alias eq='open -a /usr/local/opt/emacs-mac/Emacs.app --args -q'
    alias etq='/usr/local/bin/emacs -q'
    # symlink emacs cask here to avoid clash with brew cask
    alias ecask='/usr/local/bin/cask'

    # autojump
    [[ -s $(brew --prefix)/etc/profile.d/autojump.sh ]] && . $(brew --prefix)/etc/profile.d/autojump.sh

    # homebrew command-not-found
    # https://github.com/Homebrew/homebrew-command-not-found
    if brew command command-not-found-init > /dev/null; then
        eval "$(brew command-not-found-init)";
    fi

    # iterm2 v3 shell integration
    test -e ${HOME}/.iterm2_shell_integration.zsh &&
        source ${HOME}/.iterm2_shell_integration.zsh;

elif [[ "$OSTYPE" == linux-gnu* ]]; then
    ## emacs
    alias edae='emacs --daemon'
    alias ec='emacsclient -c'
    alias en='emacsclient -n'
    alias enc='emacsclient -nc'
    alias et='emacsclient -nw'
    alias etq='emacs -nw -q'
fi

# pyenv
if which pyenv > /dev/null; then eval "$(pyenv init -)"; fi
eval "$(pyenv virtualenv-init -)"

# vendor zsh completions
if [ -s /usr/share/zsh/vendor-completions ]; then
    fpath=(/usr/share/zsh/vendor-completions $fpath)
fi

# load OCaml's OPAM
$HOME/.opam/opam-init/init.zsh > /dev/null 2> /dev/null || true

# nvm/npm/node
# Defer initialization of nvm until nvm, node or a node-dependent command is
# run. Ensure this block is only run once if .bashrc gets sourced multiple times
# by checking whether __init_nvm is a function.
if [ -s "/usr/share/nvm/init-nvm.sh" ]; then
    export NVM_DIR="$HOME/.nvm"
    declare -a __node_commands=('nvm' 'node' 'npm' 'npx' 'yarn' 'gulp' 'grunt' 'webpack')
    function __init_nvm() {
        for i in "${__node_commands[@]}"; do unalias $i; done
        . /usr/share/nvm/init-nvm.sh
        unset __node_commands
        unset -f __init_nvm
    }
    for i in "${__node_commands[@]}"; do alias $i='__init_nvm && '$i; done
fi


## Ensure path arrays do not contain duplicates.
typeset -gU cdpath fpath mailpath path

# zprof
